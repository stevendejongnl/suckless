diff --git a/dwm/config.def.h b/dwm/config.def.h
index 7352c0d..ee88065 100644
--- a/dwm/config.def.h
+++ b/dwm/config.def.h
@@ -227,7 +227,9 @@ static const Button buttons[] = {
 	{ ClkLtSymbol,		0,		Button1,	setlayout,	{0} },
 	{ ClkLtSymbol,		0,		Button3,	setlayout,	{.v = &layouts[2]} },
 	{ ClkWinTitle,		0,		Button2,	zoom,		{0} },
-	{ ClkStatusText,	0,		Button2,	spawn,		{.v = termcmd } },
+	{ ClkStatusText,	0,		Button1,	sigstatusbar,	{.i = 1} },
+	{ ClkStatusText,	0,		Button2,	sigstatusbar,	{.i = 2} },
+	{ ClkStatusText,	0,		Button3,	sigstatusbar,	{.i = 3} },
 	{ ClkClientWin,		MODKEY,		Button1,	movemouse,	{0} },
 	{ ClkClientWin,		MODKEY,		Button2,	togglefloating, {0} },
 	{ ClkClientWin,		MODKEY,		Button3,	resizemouse,	{0} },
diff --git a/dwm/dwm.c b/dwm/dwm.c
index 09e3e99..edf4909 100644
--- a/dwm/dwm.c
+++ b/dwm/dwm.c
@@ -243,6 +243,7 @@ static void tile(Monitor *m);
 static void togglebar(const Arg *arg);
 static void togglefloating(const Arg *arg);
 static void togglescratch(const Arg *arg);
+static void sigstatusbar(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unfocus(Client *c, int setfocus);
@@ -278,6 +279,9 @@ static const char broken[] = "broken";
 static const char dwmdir[] = "dwm";
 static const char localshare[] = ".local/share";
 static char stext[256];
+static int statusw;
+static int statussig;
+static pid_t statuspid = -1;
 static int screen;
 static int sw, sh;	     /* X display screen geometry width, height */
 static int bh;		     /* bar height */
@@ -536,9 +540,24 @@ buttonpress(XEvent *e)
 			arg.ui = 1 << i;
 		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
 			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext) - getsystraywidth())
+		else if (ev->x > selmon->ww - statusw) {
+			char *text, *s, ch;
+			x = selmon->ww - statusw;
 			click = ClkStatusText;
-		else
+			statussig = 0;
+			for (text = s = stext; *s && x <= ev->x; s++) {
+				if ((unsigned char)(*s) >= 0x10 && (unsigned char)(*s) <= 0x1f) {
+					ch = *s;
+					*s = '\0';
+					x += TEXTW(text) - lrpad;
+					*s = ch;
+					text = s + 1;
+					if (x >= ev->x)
+						break;
+					statussig = ch;
+				}
+			}
+		} else
 			click = ClkWinTitle;
 	} else if ((c = wintoclient(ev->window))) {
 		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
@@ -893,7 +912,7 @@ drawbar(Monitor *m)
 
 		/* Parse and render status text with embedded color codes */
 		while (1) {
-			/* Check if current byte is a color code (0x01-0x0C) */
+			/* Check if current byte is a color code (0x01-0x0C) or statuscmd (0x10-0x1F) */
 			if ((unsigned char)*ts >= 0x01 && (unsigned char)*ts <= 0x0C) {
 				ctmp = *ts;
 				*ts = '\0'; /* temporarily terminate string */
@@ -918,6 +937,22 @@ drawbar(Monitor *m)
 				continue;
 			}
 
+			/* Skip statuscmd bytes (0x10-0x1F) - they're used for click detection, not rendering */
+			if ((unsigned char)*ts >= 0x10 && (unsigned char)*ts <= 0x1f) {
+				ctmp = *ts;
+				*ts = '\0'; /* temporarily terminate string */
+
+				/* Draw text segment up to this point */
+				if (tp < ts) {
+					drw_text(drw, m->ww - tw + tx - stw, 0, tw - tx, bh, lrpad / 2 - 2, tp, 0);
+					tx += TEXTW(tp) - lrpad;
+				}
+
+				*ts = ctmp; /* restore character */
+				tp = ++ts; /* move text pointer past statuscmd byte */
+				continue;
+			}
+
 			if (*ts == '\0') {
 				/* Draw final segment */
 				if (tp < ts)
@@ -1096,6 +1131,30 @@ getsystraywidth()
 	return w ? w + systrayspacing : 1;
 }
 
+pid_t
+getstatusbarpid()
+{
+	char buf[32], *str = buf, *c;
+	FILE *fp;
+
+	if (statuspid > 0) {
+		snprintf(buf, sizeof(buf), "/proc/%u/cmdline", statuspid);
+		if ((fp = fopen(buf, "r"))) {
+			fgets(buf, sizeof(buf), fp);
+			while ((c = strchr(str, '/')))
+				str = c + 1;
+			fclose(fp);
+			if (!strcmp(str, "statusbar.sh") || !strcmp(str, "dwmblocks"))
+				return statuspid;
+		}
+	}
+	if (!(fp = popen("pidof -s statusbar.sh || pidof -s dwmblocks 2>/dev/null", "r")))
+		return -1;
+	fgets(buf, sizeof(buf), fp);
+	pclose(fp);
+	return strtol(buf, NULL, 10);
+}
+
 int
 getrootptr(int *x, int *y)
 {
@@ -2199,6 +2258,20 @@ togglescratch(const Arg *arg)
 		spawn(arg);
 }
 
+void
+sigstatusbar(const Arg *arg)
+{
+	union sigval sv;
+
+	if (!statussig)
+		return;
+	sv.sival_int = arg->i;
+	if ((statuspid = getstatusbarpid()) <= 0)
+		return;
+
+	sigqueue(statuspid, SIGRTMIN + statussig, sv);
+}
+
 void
 toggletag(const Arg *arg)
 {
@@ -2505,8 +2578,31 @@ updatesizehints(Client *c)
 void
 updatestatus(void)
 {
-	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext))) {
 		strcpy(stext, "dwm-"VERSION);
+		statusw = TEXTW(stext) - lrpad + 2;
+	} else {
+		/* Calculate status bar width accounting for statuscmd bytes */
+		char *text, *s, ch;
+		statusw = 0;
+		for (text = s = stext; *s; s++) {
+			if ((unsigned char)(*s) >= 0x10 && (unsigned char)(*s) <= 0x1f) {
+				ch = *s;
+				*s = '\0';
+				statusw += TEXTW(text) - lrpad;
+				*s = ch;
+				text = s + 1;
+			} else if ((unsigned char)(*s) >= 0x01 && (unsigned char)(*s) <= 0x0C) {
+				/* statuscolors bytes are also not rendered */
+				ch = *s;
+				*s = '\0';
+				statusw += TEXTW(text) - lrpad;
+				*s = ch;
+				text = s + 1;
+			}
+		}
+		statusw += TEXTW(text) - lrpad + 2;
+	}
 	drawbar(selmon);
 	updatesystray();
 }
